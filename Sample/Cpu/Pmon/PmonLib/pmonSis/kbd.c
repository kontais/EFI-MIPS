#include "libc.h"
#include "kbd.h"
#include "mips_machdep.h"
#include "cfb_console.h"


/* Do not edit this file! It was automatically generated by   */
/*    loadkeys --mktable defkeymap.map > defkeymap.c          */
#define NR_KEYS		128

UINT16 plain_map[NR_KEYS] = {
	0xf200,	0xf01b,	0xf031,	0xf032,	0xf033,	0xf034,	0xf035,	0xf036,
	0xf037,	0xf038,	0xf039,	0xf030,	0xf02d,	0xf03d,	0xf07f,	0xf009,
	0xfb71,	0xfb77,	0xfb65,	0xfb72,	0xfb74,	0xfb79,	0xfb75,	0xfb69,
	0xfb6f,	0xfb70,	0xf05b,	0xf05d,	0xf201,	0xf702,	0xfb61,	0xfb73,
	0xfb64,	0xfb66,	0xfb67,	0xfb68,	0xfb6a,	0xfb6b,	0xfb6c,	0xf03b,
	0xf027,	0xf060,	0xf700,	0xf05c,	0xfb7a,	0xfb78,	0xfb63,	0xfb76,
	0xfb62,	0xfb6e,	0xfb6d,	0xf02c,	0xf02e,	0xf02f,	0xf700,	0xf30c,
	0xf703,	0xf020,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf209,	0xf307,
	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03c,	0xf10a,
	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
};
UINT16 shift_map[NR_KEYS] = {
	0xf200,	0xf01b,	0xf021,	0xf040,	0xf023,	0xf024,	0xf025,	0xf05e,
	0xf026,	0xf02a,	0xf028,	0xf029,	0xf05f,	0xf02b,	0xf07f,	0xf009,
	0xfb51,	0xfb57,	0xfb45,	0xfb52,	0xfb54,	0xfb59,	0xfb55,	0xfb49,
	0xfb4f,	0xfb50,	0xf07b,	0xf07d,	0xf201,	0xf702,	0xfb41,	0xfb53,
	0xfb44,	0xfb46,	0xfb47,	0xfb48,	0xfb4a,	0xfb4b,	0xfb4c,	0xf03a,
	0xf022,	0xf07e,	0xf700,	0xf07c,	0xfb5a,	0xfb58,	0xfb43,	0xfb56,
	0xfb42,	0xfb4e,	0xfb4d,	0xf03c,	0xf03e,	0xf03f,	0xf700,	0xf30c,
	0xf703,	0xf020,	0xf207,	0xf10a,	0xf10b,	0xf10c,	0xf10d,	0xf10e,
	0xf10f,	0xf110,	0xf111,	0xf112,	0xf113,	0xf213,	0xf203,	0xf307,
	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf03e,	0xf10a,
	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
	0xf30e,	0xf702,	0xf30d,	0xf200,	0xf701,	0xf205,	0xf114,	0xf603,
	0xf20b,	0xf601,	0xf602,	0xf117,	0xf600,	0xf20a,	0xf115,	0xf116,
	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
};

UINT16 ctrl_map[NR_KEYS] = {
	0xf200,	0xf200,	0xf200,	0xf000,	0xf01b,	0xf01c,	0xf01d,	0xf01e,
	0xf01f,	0xf07f,	0xf200,	0xf200,	0xf01f,	0xf200,	0xf008,	0xf200,
	0xf011,	0xf017,	0xf005,	0xf012,	0xf014,	0xf019,	0xf015,	0xf009,
	0xf00f,	0xf010,	0xf01b,	0xf01d,	0xf201,	0xf702,	0xf001,	0xf013,
	0xf004,	0xf006,	0xf007,	0xf008,	0xf00a,	0xf00b,	0xf00c,	0xf200,
	0xf007,	0xf000,	0xf700,	0xf01c,	0xf01a,	0xf018,	0xf003,	0xf016,
	0xf002,	0xf00e,	0xf00d,	0xf200,	0xf20e,	0xf07f,	0xf700,	0xf30c,
	0xf703,	0xf000,	0xf207,	0xf100,	0xf101,	0xf102,	0xf103,	0xf104,
	0xf105,	0xf106,	0xf107,	0xf108,	0xf109,	0xf208,	0xf204,	0xf307,
	0xf308,	0xf309,	0xf30b,	0xf304,	0xf305,	0xf306,	0xf30a,	0xf301,
	0xf302,	0xf303,	0xf300,	0xf310,	0xf206,	0xf200,	0xf200,	0xf10a,
	0xf10b,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
	0xf30e,	0xf702,	0xf30d,	0xf01c,	0xf701,	0xf205,	0xf114,	0xf603,
	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
};

#define MAX_NR_KEYMAPS	256

UINT16 *key_maps[MAX_NR_KEYMAPS] = {
	plain_map, shift_map, ctrl_map
};

UINTN keymap_count = 3;

char inputbuf[300];
static UINT8 e0_keys[128] = {
	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x00-0x07 */
	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x08-0x0f */
	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x10-0x17 */
	0, 0, 0, 0, E0_KPENTER, E0_RCTRL, 0, 0,	/* 0x18-0x1f */
	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x20-0x27 */
	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x28-0x2f */
	0, 0, 0, 0, 0, E0_KPSLASH, 0, E0_PRSCR,	/* 0x30-0x37 */
	E0_RALT, 0, 0, 0, 0, E0_F13, E0_F14, E0_HELP,	/* 0x38-0x3f */
	E0_DO, E0_F17, 0, 0, 0, 0, E0_BREAK, E0_HOME,	/* 0x40-0x47 */
	E0_UP, E0_PGUP, 0, E0_LEFT, E0_OK, E0_RIGHT, E0_KPMINPLUS, E0_END,	/* 0x48-0x4f */
	E0_DOWN, E0_PGDN, E0_INS, E0_DEL, 0, 0, 0, 0,	/* 0x50-0x57 */
	0, 0, 0, E0_MSLW, E0_MSRW, E0_MSTM, 0, 0,	/* 0x58-0x5f */
	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x60-0x67 */
	0, 0, 0, 0, 0, 0, 0, E0_MACRO,	/* 0x68-0x6f */
	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x70-0x77 */
	0, 0, 0, 0, 0, 0, 0, 0	/* 0x78-0x7f */
};
static void kbd_wait(void);
void kbd_poll(void);
char kbd_getch(void);
static int kbd_read_data(void);
static void kbd_write_command_w(int data);
static int kbd_wait_for_input(void);
static void kbd_write_output_w(int data);
static int kbd_write_command_w_and_wait(int data);
static int kbd_write_output_w_and_wait(int data);
static void kbd_clear_input(void);
int kbd_initialize(void);
int kbd_translate(UINT8 scancode, UINT8 *keycode);
static UINT8 handle_kbd_event(void);
static int do_acknowledge(UINT8 scancode);
static inline void handle_keyboard_event(UINT8 scancode);
void handle_scancode(UINT8 scancode, int down);
static void do_self(UINT8 value, char up_flag);
static void do_cons(UINT8 value, char up_flag);
static void do_fn(UINT8 value, char up_flag);
static void do_pad(UINT8 value, char up_flag);
static void do_cur(UINT8 value, char up_flag);
static void do_shift(UINT8 value, char up_flag);
static void do_null(void);
static void enter(void);
static void do_spec(UINT8 value, char up_flag);
static void do_dead(UINT8 value, char up_flag);
UINT8 kbd_code;
UINTN esc_seq;
UINTN esc_code;

typedef void (*k_hand) (UINT8 value, char up_flag);
typedef void (k_handfn) (UINT8 value, char up_flag);

static k_handfn
    do_self, do_fn, do_spec, do_pad, do_dead, do_cons, do_cur, do_shift;
/*
	do_meta, do_ascii, do_lock, do_lowercase, do_slock, do_dead2,
	do_ignore;
*/
static k_hand key_handler[16] = {
	do_self, do_fn, do_spec, do_pad, do_dead, do_cons, do_cur, do_shift,
//      do_meta, do_ascii, do_lock, do_lowercase, do_slock, do_dead2,
//      do_ignore, do_ignore
};

typedef void (*void_fnp) (void);
typedef void (void_fn) (void);

static void_fn do_null, enter;
	/*show_ptregs, send_intr, lastcons, caps_toggle,
	   num, hold, scroll_forw, scroll_back, boot_it, caps_on, compose,
	   SAK, decr_console, incr_console, spawn_console, bare_num; */

static void_fnp spec_fn_table[16] = {
	do_null, enter,		/*show_ptregs,  show_mem,
				   show_state,  send_intr,      lastcons,       caps_toggle,
				   num,         hold,           scroll_forw,    scroll_back,
				   boot_it,     caps_on,        compose,        SAK,
				   decr_console,        incr_console,   spawn_console,  bare_num */
};

int shift_state = 0;

/*
 * Wait for keyboard controller input buffer to drain.
 *
 * Don't use 'jiffies' so that we don't depend on
 * interrupts..
 *
 * Quote from PS/2 System Reference Manual:
 *
 * "Address hex 0060 and address hex 0064 should be written only when
 * the input-buffer-full bit and output-buffer-full bit in the
 * Controller Status register are set 0."
 */

static void kbd_wait(void)
{
	UINTN timeout = KBC_TIMEOUT;

	do {
		/*
		 * "handle_kbd_event()" will handle any incoming events
		 * while we wait - keypresses or mouse movement.
		 */
		UINT8 status = handle_kbd_event();

		if (!(status & KBD_STAT_IBF))
			return;
		delay(1000);
		timeout--;
	} while (timeout);
}

#define SEND_ESC_SEQ(c)	\
	esc_code = c;	\
	esc_seq = 1;

void kbd_poll()
{
	if (esc_seq) {
		switch (esc_seq) {
		case 1:
			kbd_code = 0x1b;
			esc_seq++;
			break;
		case 2:
			kbd_code = '[';
			esc_seq++;
			break;
		case 3:
			kbd_code = esc_code;
			esc_seq = 0;
		}
	} else {
		while (kbd_read_status() & KBD_STAT_OBF)
			handle_kbd_event();
	}
}

static int kbd_read_data(void)
{
	int retval = KBD_NO_DATA;
	UINT8 status;

	status = kbd_read_status();
	if (status & KBD_STAT_OBF) {
		UINT8 data = kbd_read_input();

		retval = data;
		if (status & (KBD_STAT_GTO | KBD_STAT_PERR))
			retval = KBD_BAD_DATA;
	}
	return retval;
}

static void kbd_write_command_w(int data)
{
	kbd_wait();
	kbd_write_command(data);
}

static int kbd_wait_for_input(void)
{
	long timeout = KBD_INIT_TIMEOUT;

	do {
		int retval = kbd_read_data();
		if (retval >= 0)
			return retval;
		delay(1000);
	} while (--timeout);
	return -1;
}

static void kbd_write_output_w(int data)
{
	kbd_wait();
	kbd_write_output(data);
}

static int kbd_write_command_w_and_wait(int data)
{
	kbd_write_command_w(data);
	return kbd_wait_for_input();
}

static int kbd_write_output_w_and_wait(int data)
{
	kbd_write_output_w(data);
	return kbd_wait_for_input();
}

static void kbd_clear_input(void)
{
	int maxread = 100;	/* Random number */

	do {
		if (kbd_read_data() == KBD_NO_DATA)
			break;
	} while (--maxread);
}

const char *kbd_error_msgs[] = {
	"Keyboard succesfully initialized.",
	"Keyboard failed self test",
	"Keyboard reset failed, no ACK",
	"Keyboard reset failed, no POR",
	"Disable keyboard: no ACK",
	"Enable keyboard: no ACK",
	"Set rate: no ACK",
	"Set rate: no 2nd ACK"
};



int kbd_initialize(void)
{
	int status;
	int count;

	/* Flush the buffer */
	kbd_clear_input();

	/*
	 * Test the keyboard interface.
	 * This seems to be the only way to get it going.
	 * If the test is successful a x55 is placed in the input buffer.
	 */
	kbd_write_command_w(KBD_CCMD_SELF_TEST);
	if (kbd_wait_for_input() != 0x55) {
		printf("Self test cmd failed,ignored!\n");
		//return 1;
	}

	/*
	 * Perform a keyboard interface test.  This causes the controller
	 * to test the keyboard clock and data lines.  The results of the
	 * test are placed in the input buffer.
	 */
	kbd_write_command_w(KBD_CCMD_KBD_TEST);
	if (kbd_wait_for_input() != 0x00) {
		printf("KBD_TEST cmd failed,ignored!\n");
		//return 1;
	}

	/*
	 * Enable the keyboard by allowing the keyboard clock to run.
	 */
	kbd_write_command_w(KBD_CCMD_KBD_ENABLE);

	/*
	 * Reset keyboard. If the read times out
	 * then the assumption is that no keyboard is
	 * plugged into the machine.
	 * This defaults the keyboard to scan-code set 2.
	 *
	 * Set up to try again if the keyboard asks for RESEND.
	 */
	count = 0;
	do {
		kbd_write_output_w(KBD_CMD_RESET);
		status = kbd_wait_for_input();
		if (status == KBD_REPLY_ACK)
			break;
		if (status != KBD_REPLY_RESEND) {
			printf("reset failed\n");
			if (++count > 1)
				break;
			//return 2;
		}
	} while (1);

	if (kbd_wait_for_input() != KBD_REPLY_POR) {
		printf("NO POR, ignored!\n");
		//return 3;
	}

	/*
	 * Set keyboard controller mode. During this, the keyboard should be
	 * in the disabled state.
	 *
	 * Set up to try again if the keyboard asks for RESEND.
	 */
	count = 0;
	do {
		kbd_write_output_w(KBD_CMD_DISABLE);
		status = kbd_wait_for_input();
		if (status == KBD_REPLY_ACK)
			break;
		if (status != KBD_REPLY_RESEND) {
			printf("disable failed\n");
			if (++count > 1)
				break;
			//return 4;
		}
	} while (1);

	kbd_write_command_w(KBD_CCMD_WRITE_MODE);
	kbd_write_output_w(KBD_MODE_KBD_INT
			   | KBD_MODE_SYS
			   | KBD_MODE_DISABLE_MOUSE | KBD_MODE_KCC);
	/* ibm powerpc portables need this to use scan-code set 1 -- Cort */
	if (!(kbd_write_command_w_and_wait(KBD_CCMD_READ_MODE) & KBD_MODE_KCC)) {
		/*
		 * If the controller does not support conversion,
		 * Set the keyboard to scan-code set 1.
		 */
		kbd_write_output_w(0xF0);
		kbd_wait_for_input();
		kbd_write_output_w(0x01);
		kbd_wait_for_input();
	}
	if (kbd_write_output_w_and_wait(KBD_CMD_ENABLE) != KBD_REPLY_ACK) {
		return 5;
	}

	/*
	 * Finally, set the typematic rate to maximum.
	 */
	if (kbd_write_output_w_and_wait(KBD_CMD_SET_RATE) != KBD_REPLY_ACK) {
		return 6;
	}
	if (kbd_write_output_w_and_wait(0x00) != KBD_REPLY_ACK) {
		return 7;
	}

	return 0;
}

int kbd_translate(UINT8 scancode, UINT8 *keycode)
{
	static int prev_scancode;

	/* special prefix scancodes.. */
	if (scancode == 0xe0 || scancode == 0xe1) {
		prev_scancode = scancode;
		return 0;
	}

	/* 0xFF is sent by a few keyboards, ignore it. 0x00 is error */
	if (scancode == 0x00 || scancode == 0xff) {
		prev_scancode = 0;
		return 0;
	}

	scancode &= 0x7f;

	if (prev_scancode) {
		if (prev_scancode != 0xe0) {
			return 0;
		} else {
			prev_scancode = 0;
			/*
			 *  The keyboard maintains its own internal caps lock and
			 *  num lock statuses. In caps lock mode E0 AA precedes make
			 *  code and E0 2A follows break code. In num lock mode,
			 *  E0 2A precedes make code and E0 AA follows break code.
			 *  We do our own book-keeping, so we will just ignore these.
			 */
			/*
			 *  For my keyboard there is no caps lock mode, but there are
			 *  both Shift-L and Shift-R modes. The former mode generates
			 *  E0 2A / E0 AA pairs, the latter E0 B6 / E0 36 pairs.
			 *  So, we should also ignore the latter. - aeb@cwi.nl
			 */
			if (scancode == 0x2a || scancode == 0x36)
				return 0;

			if (e0_keys[scancode])
				*keycode = e0_keys[scancode];
			else {
				return 0;
			}
		}
	} else {
		*keycode = scancode;
	}
	return 1;
}

/*
 * This reads the keyboard status port, and does the
 * appropriate action.
 *
 * It requires that we hold the keyboard controller
 * spinlock.
 */
static UINT8 handle_kbd_event(void)
{
	UINT8 status = kbd_read_status();
	UINTN work = 10000;

	while ((--work > 0) && (status & KBD_STAT_OBF)) {
		UINT8 scancode;

		scancode = kbd_read_input();

		/* Error bytes must be ignored to make the 
		   Synaptics touchpads compaq use work */
		/* Ignore error bytes */
		if (!(status & (KBD_STAT_GTO | KBD_STAT_PERR)))
		{
			if (status & KBD_STAT_MOUSE_OBF) ;	//handle_mouse_event(scancode);
			else
				handle_keyboard_event(scancode);
		}

		status = kbd_read_status();
	}

	if (!work)
		printf("controller jammed (0x%02X).\n", status);

	return status;
}

static volatile UINT8 reply_expected;
static volatile UINT8 acknowledge;
static volatile UINT8 resend;

static int do_acknowledge(UINT8 scancode)
{
	if (reply_expected) {
		/* Unfortunately, we must recognise these codes only if we know they
		 * are known to be valid (i.e., after sending a command), because there
		 * are some brain-damaged keyboards (yes, FOCUS 9000 again) which have
		 * keys with such codes :(
		 */
		if (scancode == KBD_REPLY_ACK) {
			acknowledge = 1;
			reply_expected = 0;
			return 0;
		} else if (scancode == KBD_REPLY_RESEND) {
			resend = 1;
			reply_expected = 0;
			return 0;
		}
	}
	return 1;
}

static inline void handle_keyboard_event(UINT8 scancode)
{
	if (do_acknowledge(scancode))
		handle_scancode(scancode, !(scancode & 0x80));
}

void handle_scancode(UINT8 scancode, int down)
{
	UINT8 keycode;
	char up_flag = down ? 0 : 0200;

	/*
	 *  Convert scancode to keycode
	 */
	if (!kbd_translate(scancode, &keycode))
		goto out;

	/*
	 *  Repeat a key only if the input buffers are empty or the
	 *  characters get echoed locally. This makes key repeat usable
	 *  with slow applications and under heavy loads.
	 */
	if (1) {
		UINT16 keysym;
		UINT8 type;
		
		UINT16 *key_map = key_maps[shift_state];
		if (key_map != NULL) {
			keysym = key_map[keycode];
			type = KTYP(keysym);
	//		printf("keycode = %d\n",keycode);
	//		printf("[kbd] keysym %x\n", keysym);

			if (type >= 0xf0) {
				type -= 0xf0;
				if (type == KT_LETTER) {
					type = KT_LATIN;
				}
				if (*key_handler[type]) {
					(*key_handler[type]) (keysym & 0xff,
							      up_flag);
				}
			}
		}
	}
      out:;
}

static void do_self(UINT8 value, char up_flag)
{
	if (up_flag)
		return;		/* no action, if this is a key release */
	kbd_code = value;
}

static void do_cons(UINT8 value, char up_flag)
{
	printf("do_cons value=%x\n", value);

}

static void do_fn(UINT8 value, char up_flag)
{
	if (!up_flag) {
		switch (value) {
		case 0x14:
			SEND_ESC_SEQ('H');
			break;
		case 0x16:
			SEND_ESC_SEQ('G'); /*Delete Key*/
			break;
		case 0x17:
			SEND_ESC_SEQ('F');
			break;
		}
	}
}

static void do_pad(UINT8 value, char up_flag)
{
	if (!up_flag) {
		switch (value) {
		case 0x10:
			SEND_ESC_SEQ('G');
			break;
		case 0xe:
			kbd_code = 10;
		default:
			break;
		}
	}
	printf("do_pad value=%x\n", value);
}

static void do_cur(UINT8 value, char up_flag)
{
	if (!up_flag) {
		switch (value) {
		case 0:
			SEND_ESC_SEQ('B');
			break;
		case 1:
			SEND_ESC_SEQ('D');
			break;
		case 2:
			SEND_ESC_SEQ('C');
			break;
		case 3:
			SEND_ESC_SEQ('A');
			break;
		}
	}
}

static void do_shift(UINT8 value, char up_flag)
{
	if (up_flag) {
		shift_state = 0;
	} else if (value == 0) {	//key shift
		shift_state = 1;
	} else if (value == 2) {	//key ctrl
		shift_state = 2;
	}
//      printf("do_shift value=0x%x,shift_state=0x%x\n",value,shift_state);
}

static void do_null()
{
}

static void enter(void)
{
	kbd_code = '\n';
}

static void do_spec(UINT8 value, char up_flag)
{
	if (up_flag)
		return;
	if (spec_fn_table[value])
		spec_fn_table[value] ();
}

static void do_dead(UINT8 value, char up_flag)
{
}

#define KBD_CMD_SET_LEDS    0xED	/* Set keyboard leds */

char GetChar(void)
{
	char RetChar;
	
	while(1)
	{
		if(kbd_code) {
			RetChar = kbd_code;
			kbd_code = 0;  //清空
			return RetChar;
		}
		else
		{
		    delay(5000); // 5ms
		    kbd_poll();
		}
	}	
}






void
get_line2(char *line, int how)
{
    int i;

	i = 0;
	while(1)
	{
		if(kbd_code) {
			line[i] = kbd_code;
			i++;
			// 回显
			video_putc(kbd_code);
			
			if (i > LINESZ ) 		//超过一行
				break;
			if ( kbd_code == '\n') 	// 回车
				break;

			//清空
			kbd_code = 0;
		}
		else
		{
		    delay(5000); // 5ms
		    kbd_poll();
		}
	}

	kbd_code = 0;
	
    if(i > 0) {
        i--;
    }
	
    line[i] = '\0';
}

int KbdInit(void)
{
	int rc;
	
	rc = kbd_initialize();
    if (rc != 0) {
      printf("%s\n",kbd_error_msgs[rc]);
    }
	return rc;
}


